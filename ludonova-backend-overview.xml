This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-17T17:49:58.136Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  main/
    java/
      com/
        bht/
          ludonova/
            config/
              DataInitializer.java
              WebConfig.java
            controller/
              AuthController.java
              GameController.java
              SteamAuthController.java
              TestController.java
              UserController.java
            dto/
              auth/
                AuthenticationResponse.java
                LoginRequest.java
                RefreshTokenRequest.java
                TokenResponse.java
              steam/
                SteamApiResponseDTO.java
                SteamAuthRequest.java
                SteamUserDTO.java
              user/
                UserDTO.java
              ErrorResponse.java
            exception/
              AuthenticationException.java
              GlobalExceptionHandler.java
              LudoNovaException.java
              SteamAuthenticationException.java
            model/
              Game.java
              SteamUser.java
              User.java
            repository/
              GameRepository.java
              UserRepository.java
            security/
              AuthenticationExceptionHandler.java
              CustomUserDetailsService.java
              JwtAuthenticationFilter.java
              JwtTokenProvider.java
              SecurityConfig.java
            service/
              auth/
                AuthenticationStrategy.java
                BasicAuthenticationStrategy.java
                SteamAuthenticationStrategy.java
              AuthenticationService.java
              SteamService.java
              UserService.java
            LudoNovaApplication.java
    resources/
      application.properties
.env.example
.gitignore
backend-overview.md
docker-compose.yml
ludonova-backend-overview.xml
pom.xml
README.md
setup.sh
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/bht/ludonova/config/DataInitializer.java">
package com.bht.ludonova.config;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class DataInitializer {

    @Bean
    CommandLineRunner initDatabase(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        return args -> {
            // Create test user if it doesn't exist
            if (userRepository.findByUsername("test").isEmpty()) {
                User testUser = User.builder()
                        .username("test")
                        .password(passwordEncoder.encode("test123"))
                        .email("test@example.com")
                        .build();
                userRepository.save(testUser);
                System.out.println("Test user created successfully");
            }
        };
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/config/WebConfig.java">
package com.bht.ludonova.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class WebConfig {

    @Value("${cors.allowed-origins}")
    private List<String> allowedOrigins;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowedOrigins);
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(List.of(
                "Authorization",
                "Content-Type",
                "X-Requested-With",
                "Accept",
                "Origin",
                "Access-Control-Request-Method",
                "Access-Control-Request-Headers"
        ));
        configuration.setExposedHeaders(List.of(
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/AuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.RefreshTokenRequest;
import com.bht.ludonova.dto.auth.LoginRequest;
import com.bht.ludonova.service.AuthenticationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@Slf4j
public class AuthController {
    private final AuthenticationService authService;

    public AuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        Map<String, String> credentials = Map.of(
                "username", loginRequest.getUsername(),
                "password", loginRequest.getPassword()
        );

        AuthenticationResponse response = authService.authenticate("basic", credentials);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
        AuthenticationResponse response = authService.refresh(request.getRefreshToken());
        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/GameController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.repository.GameRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/games")
public class GameController {

    @Autowired
    private GameRepository gameRepository;

    @GetMapping
    public ResponseEntity<List<Game>> getGames(@AuthenticationPrincipal UserDetails userDetails) {
        // For now, return an empty list rather than null
        return ResponseEntity.ok(List.of());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Game> getGame(@PathVariable Long id) {
        return gameRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/SteamAuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.service.AuthenticationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@RestController
@RequestMapping("/api/auth/steam")
@Slf4j
public class SteamAuthController {
    private final AuthenticationService authService;

    @Value("${steam.return.url}")
    private String returnUrl;

    @Value("${steam.realm.url}")
    private String realmUrl;

    public SteamAuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @GetMapping("/login")
    public ResponseEntity<Map<String, String>> steamLogin() {
        try {
            String steamOpenIdUrl = buildSteamOpenIdUrl();
            return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
        } catch (Exception e) {
            log.error("Error generating Steam login URL", e);
            throw new SteamAuthenticationException("Failed to generate Steam login URL");
        }
    }

    @GetMapping("/return")
    public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
        log.debug("Received Steam return params: {}", params);
        AuthenticationResponse response = authService.authenticate("steam", params);
        return ResponseEntity.ok(response);
    }

    private String buildSteamOpenIdUrl() {
        try {
            String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
            String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);

            return String.format(
                    "https://steamcommunity.com/openid/login" +
                            "?openid.ns=%s" +
                            "&openid.mode=checkid_setup" +
                            "&openid.return_to=%s" +
                            "&openid.realm=%s" +
                            "&openid.identity=%s" +
                            "&openid.claimed_id=%s",
                    URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
                    encodedReturnUrl,
                    encodedRealm,
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
            );
        } catch (Exception e) {
            log.error("Error building Steam OpenID URL", e);
            throw new SteamAuthenticationException("Failed to build Steam authentication URL");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/TestController.java">
package com.bht.ludonova.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
public class TestController {

    @GetMapping("/public")
    public ResponseEntity<String> publicEndpoint() {
        return ResponseEntity.ok("Public endpoint is working!");
    }

    @GetMapping("/protected")
    public ResponseEntity<String> protectedEndpoint() {
        return ResponseEntity.ok("Protected endpoint is working! You are authenticated.");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/UserController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserRepository userRepository;

    @GetMapping
    public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    // Don't send the password in the response
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java">
package com.bht.ludonova.dto.auth;

import com.bht.ludonova.dto.user.UserDTO;
import lombok.Data;

@Data
public class AuthenticationResponse {
    private final TokenResponse tokens;
    private final UserDTO user;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class RefreshTokenRequest {
    private String refreshToken;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class TokenResponse {
    private final String accessToken;
    private final String refreshToken;
    private final String tokenType;
    private final long expiresIn;

    public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
        return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java">
package com.bht.ludonova.dto.steam;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

@Data
public class SteamApiResponseDTO {
    private Response response;

    @Data
    public static class Response {
        private List<Player> players;
    }

    @Data
    public static class Player {
        @JsonProperty("steamid")
        private String steamId;

        @JsonProperty("personaname")
        private String personaName;

        @JsonProperty("profileurl")
        private String profileUrl;

        @JsonProperty("avatar")
        private String avatarUrl;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

import java.util.Map;

@Data
public class SteamAuthRequest {
    private final Map<String, String> openIdParams;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

@Data
public class SteamUserDTO {
    private String steamId;
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/user/UserDTO.java">
package com.bht.ludonova.dto.user;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import lombok.Data;

@Data
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private SteamUserDTO steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/ErrorResponse.java">
package com.bht.ludonova.dto;

import lombok.Data;

@Data
public class ErrorResponse {
    private final String errorCode;
    private final String message;
    private final int status;
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/AuthenticationException.java">
package com.bht.ludonova.exception;

public class AuthenticationException extends LudoNovaException {
    public AuthenticationException(String message) {
        super(message, "AUTH_ERROR");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java">
package com.bht.ludonova.exception;

import com.bht.ludonova.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(SteamAuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/LudoNovaException.java">
package com.bht.ludonova.exception;

public class LudoNovaException extends RuntimeException {
    private final String errorCode;

    public LudoNovaException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java">
package com.bht.ludonova.exception;

public class SteamAuthenticationException extends AuthenticationException {
    public SteamAuthenticationException(String message) {
        super("Steam authentication failed: " + message);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/model/Game.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "games")
public class Game {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false)
    private String platform;

    @Column(nullable = false)
    private String status;

    private Double rating;

    private String notes;

    @Column(name = "last_played")
    private String lastPlayed;

    @Column(name = "play_time")
    private Integer playTime;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/SteamUser.java">
package com.bht.ludonova.model;

import lombok.Data;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Data
@Entity
@Table(name = "steam_users")
public class SteamUser {
    @Id
    private String steamId;
    
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
    
    @OneToOne(mappedBy = "steamUser")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/User.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column
    private String email;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "steam_id")
    private SteamUser steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/GameRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Game;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface GameRepository extends JpaRepository<Game, Long> {
    List<Game> findByUserId(Long userId);
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/UserRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findBySteamUser_SteamId(String steamId);
}
</file>

<file path="src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java">
package com.bht.ludonova.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        log.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        log.error("Access denied error: {}", accessDeniedException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_FORBIDDEN);
        body.put("error", "Forbidden");
        body.put("message", accessDeniedException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java">
package com.bht.ludonova.security;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
                .accountExpired(false)
                .accountLocked(false)
                .credentialsExpired(false)
                .disabled(false)
                .build();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java">
package com.bht.ludonova.security;

import com.bht.ludonova.exception.AuthenticationException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService customUserDetailsService;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // List of paths that don't require authentication
    private final List<String> publicPaths = Arrays.asList(
            "/api/auth/**",
            "/api/test/public"
    );

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getServletPath();
        return publicPaths.stream()
                .anyMatch(pattern -> pathMatcher.match(pattern, path));
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt)) {
                if (!tokenProvider.validateToken(jwt)) {
                    throw new AuthenticationException("Invalid or expired JWT token");
                }

                String username = tokenProvider.getUsernameFromToken(jwt);
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
            SecurityContextHolder.clearContext();

            if (ex instanceof AuthenticationException) {
                throw ex;
            }
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * Helper method to check if token is about to expire
     * Could be used to implement token refresh logic
     */
    private boolean shouldRefreshToken(String token) {
        return tokenProvider.isTokenExpired(token, false);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtTokenProvider.java">
package com.bht.ludonova.security;


import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey accessTokenKey;
    private final SecretKey refreshTokenKey;
    private final long accessTokenExpirationMs; // Changed to long
    private final long refreshTokenExpirationMs; // Changed to long

    public JwtTokenProvider(
            @Value("${jwt.secret}") String jwtSecret,
            @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
            @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
            @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
        this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
        this.accessTokenExpirationMs = accessTokenExpirationMs;
        this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    }

    public String generateAccessToken(Authentication authentication) {
        return generateAccessToken(authentication.getName(), createClaims(authentication));
    }

    public String generateAccessToken(String username) {
        return generateAccessToken(username, new HashMap<>());
    }

    public String generateAccessToken(String username, Map<String, Object> claims) {
        return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
    }

    public String generateRefreshToken(String username) {
        return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
    }

    private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMs);

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    private Map<String, Object> createClaims(Authentication authentication) {
        Map<String, Object> claims = new HashMap<>();

        // Add user authorities/roles
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        claims.put("authorities", authorities);

        // Add token type
        claims.put("type", "Bearer");

        return claims;
    }

    public String getUsernameFromToken(String token, boolean isRefreshToken) {
        return getClaimsFromToken(token, isRefreshToken).getSubject();
    }

    public String getUsernameFromToken(String token) {
        return getUsernameFromToken(token, false);
    }

    public boolean validateToken(String token) {
        return validateToken(token, false);
    }

    public boolean validateToken(String token, boolean isRefreshToken) {
        try {
            SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            log.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenExpired(String token, boolean isRefreshToken) {
        try {
            Claims claims = getClaimsFromToken(token, isRefreshToken);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    public long getAccessTokenExpirationMs() {
        return accessTokenExpirationMs;
    }

    public long getRefreshTokenExpirationMs() {
        return refreshTokenExpirationMs;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/SecurityConfig.java">
package com.bht.ludonova.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthFilter;
    private final CorsConfigurationSource corsConfigurationSource;
    private final AuthenticationExceptionHandler authenticationExceptionHandler;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers(
                                "/api/auth/login",
                                "/api/auth/refresh",
                                "/api/auth/steam/login",
                                "/api/auth/steam/return"
                        ).permitAll()
                        .requestMatchers("/api/test/public").permitAll()
                        // Protected endpoints
                        .requestMatchers("/api/games/**").authenticated()
                        .requestMatchers("/api/user/**").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exc -> exc
                        .authenticationEntryPoint(authenticationExceptionHandler)
                        .accessDeniedHandler(authenticationExceptionHandler)
                )
                .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;

import java.util.Map;

public interface AuthenticationStrategy {
    AuthenticationResponse authenticate(Map<String, String> credentials);
    AuthenticationResponse refresh(String refreshToken);
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class BasicAuthenticationStrategy implements AuthenticationStrategy {
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    public BasicAuthenticationStrategy(
            AuthenticationManager authenticationManager,
            JwtTokenProvider tokenProvider,
            UserService userService) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.userService = userService;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> credentials) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            credentials.get("username"),
                            credentials.get("password")
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);

            String accessToken = tokenProvider.generateAccessToken(authentication);
            String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
            UserDTO user = userService.getCurrentUserDTO();

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (org.springframework.security.core.AuthenticationException e) {
            log.error("Authentication failed", e);
            throw new AuthenticationException("Invalid username or password");
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        try {
            if (!tokenProvider.validateToken(refreshToken, true)) {
                throw new AuthenticationException("Invalid refresh token");
            }

            String username = tokenProvider.getUsernameFromToken(refreshToken, true);
            UserDTO user = userService.getUserDTOByUsername(username);

            String newAccessToken = tokenProvider.generateAccessToken(username);
            String newRefreshToken = tokenProvider.generateRefreshToken(username);

            TokenResponse tokens = TokenResponse.of(
                    newAccessToken,
                    newRefreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (Exception e) {
            log.error("Token refresh failed", e);
            throw new AuthenticationException("Failed to refresh token");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.SteamService;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class SteamAuthenticationStrategy implements AuthenticationStrategy {
    private final SteamService steamService;
    private final UserService userService;
    private final JwtTokenProvider tokenProvider;

    public SteamAuthenticationStrategy(
            SteamService steamService,
            UserService userService,
            JwtTokenProvider tokenProvider) {
        this.steamService = steamService;
        this.userService = userService;
        this.tokenProvider = tokenProvider;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
        try {
            log.debug("Starting Steam authentication with params: {}", openIdParams);

            if (!steamService.validateSteamResponse(openIdParams)) {
                log.error("Steam validation failed");
                throw new SteamAuthenticationException("Invalid Steam response");
            }

            log.debug("Steam response validated successfully");
            String steamId = extractSteamId(openIdParams);

            if (steamId == null) {
                log.error("Could not extract Steam ID from params");
                throw new SteamAuthenticationException("Could not extract Steam ID");
            }

            log.debug("Extracted Steam ID: {}", steamId);
            SteamUser steamUser = steamService.fetchUserDetails(steamId);
            log.debug("Fetched Steam user details: {}", steamUser);

            User user = userService.getOrCreateSteamUser(steamUser);
            log.debug("Got/Created user: {}", user);

            String accessToken = tokenProvider.generateAccessToken(user.getUsername());
            String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
            UserDTO userDTO = userService.convertToDTO(user);

            log.debug("Generated tokens and converted user to DTO");

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, userDTO);
        } catch (Exception e) {
            log.error("Steam authentication failed", e);
            throw new SteamAuthenticationException(e.getMessage());
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        return null; // Steam users use the same refresh mechanism as basic auth
    }

    private String extractSteamId(Map<String, String> params) {
        String identity = params.get("openid.claimed_id");
        if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
            return identity.substring(identity.lastIndexOf("/") + 1);
        }
        return null;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/AuthenticationService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.service.auth.AuthenticationStrategy;
import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class AuthenticationService {
    private final Map<String, AuthenticationStrategy> authenticationStrategies;

    public AuthenticationService(
            BasicAuthenticationStrategy basicAuthStrategy,
            SteamAuthenticationStrategy steamAuthStrategy) {
        this.authenticationStrategies = Map.of(
                "basic", basicAuthStrategy,
                "steam", steamAuthStrategy
        );
    }

    public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
        AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
        if (authStrategy == null) {
            throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
        }

        return authStrategy.authenticate(credentials);
    }

    public AuthenticationResponse refresh(String refreshToken) {
        // We use the basic strategy for refresh tokens as the mechanism is the same
        return authenticationStrategies.get("basic").refresh(refreshToken);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/SteamService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import com.bht.ludonova.model.SteamUser;
import lombok.extern.slf4j.Slf4j;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Service
public class SteamService {
    @Value("${steam.api.key}")
    private String steamApiKey;

    private final WebClient steamApiClient;
    private final WebClient openIdClient;

    public SteamService() {
        this.steamApiClient = WebClient.builder()
                .baseUrl("https://api.steampowered.com")
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();

        this.openIdClient = WebClient.builder()
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(16 * 1024 * 1024))
                .build();
    }

    public boolean validateSteamResponse(Map<String, String> params) {
        try {
            log.info("Validating Steam response with params: {}", params);
            String url = "https://steamcommunity.com/openid/login";

            // Create a new map with check_authentication mode
            Map<String, String> validationParams = new HashMap<>(params);
            validationParams.put("openid.mode", "check_authentication");

            // Convert map to form data
            String formData = validationParams.entrySet().stream()
                    .map(entry -> entry.getKey() + "=" + encodeValue(entry.getValue()))
                    .collect(Collectors.joining("&"));

            String responseBody = openIdClient.post()
                    .uri(url)
                    .header("Content-Type", "application/x-www-form-urlencoded")
                    .bodyValue(formData)
                    .retrieve()
                    .bodyToMono(String.class)
                    .block();

            log.info("Steam validation response: {}", responseBody);
            return responseBody != null && responseBody.contains("is_valid:true");
        } catch (Exception e) {
            log.error("Error validating Steam response", e);
            return false;
        }
    }

    public SteamUser fetchUserDetails(String steamId) {
        String url = "/ISteamUser/GetPlayerSummaries/v2/";

        try {
            SteamApiResponseDTO dto = steamApiClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path(url)
                            .queryParam("key", steamApiKey)
                            .queryParam("steamids", steamId)
                            .build())
                    .retrieve()
                    .bodyToMono(SteamApiResponseDTO.class)
                    .block();

            if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
                SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
                return mapToSteamUser(player);
            }

            throw new SteamApiException("Failed to fetch Steam user details");
        } catch (Exception e) {
            log.error("Error fetching Steam user details", e);
            throw new SteamApiException("Failed to fetch Steam user details", e);
        }
    }

    private String encodeValue(String value) {
        try {
            return URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
        } catch (UnsupportedEncodingException e) {
            return value;
        }
    }

    private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
        SteamUser steamUser = new SteamUser();
        steamUser.setSteamId(player.getSteamId());
        steamUser.setPersonaName(player.getPersonaName());
        steamUser.setProfileUrl(player.getProfileUrl());
        steamUser.setAvatarUrl(player.getAvatarUrl());
        return steamUser;
    }

    public static class SteamApiException extends RuntimeException {
        public SteamApiException(String message) {
            super(message);
        }

        public SteamApiException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/UserService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;

import java.util.UUID;

@Service
@Transactional
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public User getOrCreateSteamUser(SteamUser steamUser) {
        return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
                .orElseGet(() -> createSteamUser(steamUser));
    }

    private User createSteamUser(SteamUser steamUser) {
        User user = new User();
        user.setUsername("steam_" + steamUser.getSteamId());
        user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
        user.setSteamUser(steamUser);
        return userRepository.save(user);
    }

    public UserDTO getCurrentUserDTO() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    public UserDTO getUserDTOByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + username));
    }

    public UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());

        if (user.getSteamUser() != null) {
            SteamUserDTO steamUserDTO = new SteamUserDTO();
            steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
            steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
            steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
            steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
            dto.setSteamUser(steamUserDTO);
        }

        return dto;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/LudoNovaApplication.java">
package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
@EntityScan("com.bht.ludonova.model")
@EnableJpaRepositories("com.bht.ludonova.repository")
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}
</file>

<file path="src/main/resources/application.properties">
# Server Configuration
server.port=8080

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres

# JPA/Hibernate Configuration
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Enable SQL initialization
spring.sql.init.mode=always

# JWT Configuration
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E

# Token expiration times (in milliseconds)
# Access token: 1 hour = 3600000 ms
jwt.expiration=3600000
# Refresh token: 30 days = 2592000000 ms
jwt.refresh-expiration=2592000000

# CORS Configuration
#spring.web.cors.allowed-origins=http://localhost:3000
#spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
#spring.web.cors.allowed-headers=*
#spring.web.cors.allow-credentials=true

# CORS Configuration
cors.allowed-origins=http://localhost:3000

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Steam Configuration
steam.api.key=${STEAM_API_KEY}
steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
</file>

<file path=".env.example">
# Steam Configuration
STEAM_API_KEY=your_steam_api_key_here
STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
</file>

<file path=".gitignore">
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Environment Files ###
.env
application-local.properties
application-dev.properties
application-prod.properties

### Logs ###
*.log
logs/
log/

### Docker ###
docker-compose.override.yml

### OS generated files ###
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

### Java ###
# Compiled class file
*.class

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs
hs_err_pid*
replay_pid*
</file>

<file path="backend-overview.md">
# LudoNova Backend Overview

The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.

## Understanding Spring and Spring Boot

Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.

### What is Spring?

**Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:

- **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
- **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
- **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
- **Transaction Management:** Provides declarative transaction management for consistent data operations.
- **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.

However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.

### What is Spring Boot?

**Spring Boot** builds upon the Spring framework to simplify the development process. It offers:

- **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
- **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
- **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
- **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.

In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.

## Architecture

The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:

- **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
  
  - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.

- **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
  
  - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.

- **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
  
  - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.

### How These Layers Work Together

1. **Request Flow:**
   - A client sends an HTTP request to the application.
   - The **Controller** receives the request and delegates processing to the **Service** layer.
   - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
   - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
   - The **Service** processes the data and returns the result to the **Controller**.
   - The **Controller** sends the appropriate HTTP response back to the client.

2. **Benefits of Layered Architecture:**
   - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
   - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
   - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
   - **Maintainability:** Enhances code readability and simplifies the addition of new features.

## Authentication and Security

Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.

### Understanding Spring Security

**Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:

- **Authentication:** Verifies the identity of users.
- **Authorization:** Controls access to resources based on user roles and permissions.
- **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.

### Key Components:

- **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
  
  ```java
  public String generateToken(String username) { /* ... */ }
  public String getUsernameFromJWT(String token) { /* ... */ }
  public boolean validateToken(String authToken) { /* ... */ }
  ```
  
  - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.

- **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
  
  - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.

- **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
  
  - **Configuration Highlights:**
    - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
    - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
    - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
    - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.

### Security Features:

- **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
  
  - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.

- **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
  
  - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.

- **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
  
  - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.

## API Endpoints

The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.

### Examples:

- **Authentication:**
  - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
  - `POST /api/auth/register`: Registers a new user.

- **Games Management:**
  - `GET /api/games`: Retrieves a list of games.
  - `POST /api/games`: Adds a new game to the backlog.
  - `PUT /api/games/{id}`: Updates game details.
  - `DELETE /api/games/{id}`: Removes a game from the backlog.

- **User Profiles:**
  - `GET /api/user`: Retrieves the authenticated user's profile information.

### Leveraging Spring MVC:

- **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
- **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
- **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.

## Database Management

The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.

### Benefits of Using JPA/Hibernate:

- **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
- **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
- **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.

### Configuration:

```properties
# application.properties
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=yourusername
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
```

- **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
- **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.

## Testing and Deployment

### Testing:

Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.

- **Running Tests:**
  
  ```bash
  ./mvnw test
  ```
  
  - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
  
- **Benefits:**
  - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
  - **Quality Assurance:** Maintains high code quality and reliability.

### Deployment:

The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.

- **Containerization with Docker:**
  
  ```bash
  docker-compose up -d
  ```
  
  - **Advantages:**
    - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
    - **Scalability:** Simplifies scaling services horizontally.
    - **Portability:** Enables easy deployment across different environments and cloud platforms.

### Prerequisites:

- **Java 17+:** Required to run the Spring Boot application.
- **Maven:** For building and managing dependencies.
- **Docker and Docker Compose:** For containerization and deployment.

## Integration with Frontend

The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.

### API Client:

A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.

```javascript
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
```

- **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.

## Conclusion

The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.

```
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: ludonova_db
    environment:
      POSTGRES_DB: ludonova
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</file>

<file path="ludonova-backend-overview.xml">
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-17T15:08:49.780Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  main/
    java/
      com/
        bht/
          ludonova/
            config/
              DataInitializer.java
              WebConfig.java
            controller/
              AuthController.java
              GameController.java
              SteamAuthController.java
              TestController.java
              UserController.java
            dto/
              auth/
                AuthenticationResponse.java
                LoginRequest.java
                RefreshTokenRequest.java
                TokenResponse.java
              steam/
                SteamApiResponseDTO.java
                SteamAuthRequest.java
                SteamUserDTO.java
              user/
                UserDTO.java
              ErrorResponse.java
            exception/
              AuthenticationException.java
              GlobalExceptionHandler.java
              LudoNovaException.java
              SteamAuthenticationException.java
            model/
              Game.java
              SteamUser.java
              User.java
            repository/
              GameRepository.java
              UserRepository.java
            security/
              AuthenticationExceptionHandler.java
              CustomUserDetailsService.java
              JwtAuthenticationFilter.java
              JwtTokenProvider.java
              SecurityConfig.java
            service/
              auth/
                AuthenticationStrategy.java
                BasicAuthenticationStrategy.java
                SteamAuthenticationStrategy.java
              AuthenticationService.java
              SteamService.java
              UserService.java
            LudoNovaApplication.java
    resources/
      application.properties
.env.example
.gitignore
backend-overview.md
docker-compose.yml
pom.xml
README.md
setup.sh
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/bht/ludonova/config/DataInitializer.java">
package com.bht.ludonova.config;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class DataInitializer {

    @Bean
    CommandLineRunner initDatabase(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        return args -> {
            // Create test user if it doesn't exist
            if (userRepository.findByUsername("test").isEmpty()) {
                User testUser = User.builder()
                        .username("test")
                        .password(passwordEncoder.encode("test123"))
                        .email("test@example.com")
                        .build();
                userRepository.save(testUser);
                System.out.println("Test user created successfully");
            }
        };
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/config/WebConfig.java">
package com.bht.ludonova.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.List;

@Configuration
public class WebConfig {

    @Value("${cors.allowed-origins}")
    private List<String> allowedOrigins;

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowedOrigins);
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(List.of(
                "Authorization",
                "Content-Type",
                "X-Requested-With",
                "Accept",
                "Origin",
                "Access-Control-Request-Method",
                "Access-Control-Request-Headers"
        ));
        configuration.setExposedHeaders(List.of(
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/AuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.RefreshTokenRequest;
import com.bht.ludonova.dto.auth.LoginRequest;
import com.bht.ludonova.service.AuthenticationService;
import jakarta.validation.Valid;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@Slf4j
public class AuthController {
    private final AuthenticationService authService;

    public AuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        Map<String, String> credentials = Map.of(
                "username", loginRequest.getUsername(),
                "password", loginRequest.getPassword()
        );

        AuthenticationResponse response = authService.authenticate("basic", credentials);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {
        AuthenticationResponse response = authService.refresh(request.getRefreshToken());
        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/GameController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.Game;
import com.bht.ludonova.repository.GameRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/games")
public class GameController {

    @Autowired
    private GameRepository gameRepository;

    @GetMapping
    public ResponseEntity<List<Game>> getGames(@AuthenticationPrincipal UserDetails userDetails) {
        // For now, return an empty list rather than null
        return ResponseEntity.ok(List.of());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Game> getGame(@PathVariable Long id) {
        return gameRepository.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/SteamAuthController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.service.AuthenticationService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@RestController
@RequestMapping("/api/auth/steam")
@Slf4j
public class SteamAuthController {
    private final AuthenticationService authService;

    @Value("${steam.return.url}")
    private String returnUrl;

    @Value("${steam.realm.url}")
    private String realmUrl;

    public SteamAuthController(AuthenticationService authService) {
        this.authService = authService;
    }

    @GetMapping("/login")
    public ResponseEntity<Map<String, String>> steamLogin() {
        try {
            String steamOpenIdUrl = buildSteamOpenIdUrl();
            return ResponseEntity.ok(Map.of("url", steamOpenIdUrl));
        } catch (Exception e) {
            log.error("Error generating Steam login URL", e);
            throw new SteamAuthenticationException("Failed to generate Steam login URL");
        }
    }

    @GetMapping("/return")
    public ResponseEntity<AuthenticationResponse> steamReturn(@RequestParam Map<String, String> params) {
        log.debug("Received Steam return params: {}", params);
        AuthenticationResponse response = authService.authenticate("steam", params);
        return ResponseEntity.ok(response);
    }

    private String buildSteamOpenIdUrl() {
        try {
            String encodedReturnUrl = URLEncoder.encode(returnUrl, StandardCharsets.UTF_8);
            String encodedRealm = URLEncoder.encode(realmUrl, StandardCharsets.UTF_8);

            return String.format(
                    "https://steamcommunity.com/openid/login" +
                            "?openid.ns=%s" +
                            "&openid.mode=checkid_setup" +
                            "&openid.return_to=%s" +
                            "&openid.realm=%s" +
                            "&openid.identity=%s" +
                            "&openid.claimed_id=%s",
                    URLEncoder.encode("http://specs.openid.net/auth/2.0", StandardCharsets.UTF_8),
                    encodedReturnUrl,
                    encodedRealm,
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8),
                    URLEncoder.encode("http://specs.openid.net/auth/2.0/identifier_select", StandardCharsets.UTF_8)
            );
        } catch (Exception e) {
            log.error("Error building Steam OpenID URL", e);
            throw new SteamAuthenticationException("Failed to build Steam authentication URL");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/TestController.java">
package com.bht.ludonova.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/test")
public class TestController {

    @GetMapping("/public")
    public ResponseEntity<String> publicEndpoint() {
        return ResponseEntity.ok("Public endpoint is working!");
    }

    @GetMapping("/protected")
    public ResponseEntity<String> protectedEndpoint() {
        return ResponseEntity.ok("Protected endpoint is working! You are authenticated.");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/controller/UserController.java">
package com.bht.ludonova.controller;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/user")
public class UserController {

    @Autowired
    private UserRepository userRepository;

    @GetMapping
    public ResponseEntity<User> getCurrentUser(@AuthenticationPrincipal UserDetails userDetails) {
        return userRepository.findByUsername(userDetails.getUsername())
                .map(user -> {
                    // Don't send the password in the response
                    user.setPassword(null);
                    return ResponseEntity.ok(user);
                })
                .orElse(ResponseEntity.notFound().build());
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/AuthenticationResponse.java">
package com.bht.ludonova.dto.auth;

import com.bht.ludonova.dto.user.UserDTO;
import lombok.Data;

@Data
public class AuthenticationResponse {
    private final TokenResponse tokens;
    private final UserDTO user;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/LoginRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class LoginRequest {
    private String username;
    private String password;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/RefreshTokenRequest.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class RefreshTokenRequest {
    private String refreshToken;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/auth/TokenResponse.java">
package com.bht.ludonova.dto.auth;

import lombok.Data;

@Data
public class TokenResponse {
    private final String accessToken;
    private final String refreshToken;
    private final String tokenType;
    private final long expiresIn;

    public static TokenResponse of(String accessToken, String refreshToken, long expiresIn) {
        return new TokenResponse(accessToken, refreshToken, "Bearer", expiresIn);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamApiResponseDTO.java">
package com.bht.ludonova.dto.steam;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

@Data
public class SteamApiResponseDTO {
    private Response response;

    @Data
    public static class Response {
        private List<Player> players;
    }

    @Data
    public static class Player {
        @JsonProperty("steamid")
        private String steamId;

        @JsonProperty("personaname")
        private String personaName;

        @JsonProperty("profileurl")
        private String profileUrl;

        @JsonProperty("avatar")
        private String avatarUrl;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamAuthRequest.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

import java.util.Map;

@Data
public class SteamAuthRequest {
    private final Map<String, String> openIdParams;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/steam/SteamUserDTO.java">
package com.bht.ludonova.dto.steam;

import lombok.Data;

@Data
public class SteamUserDTO {
    private String steamId;
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/user/UserDTO.java">
package com.bht.ludonova.dto.user;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import lombok.Data;

@Data
public class UserDTO {
    private Long id;
    private String username;
    private String email;
    private SteamUserDTO steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/dto/ErrorResponse.java">
package com.bht.ludonova.dto;

import lombok.Data;

@Data
public class ErrorResponse {
    private final String errorCode;
    private final String message;
    private final int status;
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/AuthenticationException.java">
package com.bht.ludonova.exception;

public class AuthenticationException extends LudoNovaException {
    public AuthenticationException(String message) {
        super(message, "AUTH_ERROR");
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/GlobalExceptionHandler.java">
package com.bht.ludonova.exception;

import com.bht.ludonova.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(SteamAuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleSteamAuthenticationException(SteamAuthenticationException ex) {
        ErrorResponse error = new ErrorResponse(
                ex.getErrorCode(),
                ex.getMessage(),
                HttpStatus.UNAUTHORIZED.value()
        );
        return new ResponseEntity<>(error, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                HttpStatus.INTERNAL_SERVER_ERROR.value()
        );
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/LudoNovaException.java">
package com.bht.ludonova.exception;

public class LudoNovaException extends RuntimeException {
    private final String errorCode;

    public LudoNovaException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/exception/SteamAuthenticationException.java">
package com.bht.ludonova.exception;

public class SteamAuthenticationException extends AuthenticationException {
    public SteamAuthenticationException(String message) {
        super("Steam authentication failed: " + message);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/model/Game.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "games")
public class Game {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false)
    private String platform;

    @Column(nullable = false)
    private String status;

    private Double rating;

    private String notes;

    @Column(name = "last_played")
    private String lastPlayed;

    @Column(name = "play_time")
    private Integer playTime;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/SteamUser.java">
package com.bht.ludonova.model;

import lombok.Data;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Data
@Entity
@Table(name = "steam_users")
public class SteamUser {
    @Id
    private String steamId;
    
    private String personaName;
    private String profileUrl;
    private String avatarUrl;
    
    @OneToOne(mappedBy = "steamUser")
    private User user;
}
</file>

<file path="src/main/java/com/bht/ludonova/model/User.java">
package com.bht.ludonova.model;

import jakarta.persistence.*;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column
    private String email;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "steam_id")
    private SteamUser steamUser;
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/GameRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.Game;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface GameRepository extends JpaRepository<Game, Long> {
    List<Game> findByUserId(Long userId);
}
</file>

<file path="src/main/java/com/bht/ludonova/repository/UserRepository.java">
package com.bht.ludonova.repository;

import com.bht.ludonova.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findBySteamUser_SteamId(String steamId);
}
</file>

<file path="src/main/java/com/bht/ludonova/security/AuthenticationExceptionHandler.java">
package com.bht.ludonova.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
public class AuthenticationExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException, ServletException {
        log.error("Unauthorized error: {}", authException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response,
                       AccessDeniedException accessDeniedException) throws IOException, ServletException {
        log.error("Access denied error: {}", accessDeniedException.getMessage());

        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);

        Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_FORBIDDEN);
        body.put("error", "Forbidden");
        body.put("message", accessDeniedException.getMessage());
        body.put("path", request.getServletPath());

        objectMapper.writeValue(response.getOutputStream(), body);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/CustomUserDetailsService.java">
package com.bht.ludonova.security;

import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collections;

@Slf4j
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));

        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getUsername())
                .password(user.getPassword())
                .authorities(Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")))
                .accountExpired(false)
                .accountLocked(false)
                .credentialsExpired(false)
                .disabled(false)
                .build();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtAuthenticationFilter.java">
package com.bht.ludonova.security;

import com.bht.ludonova.exception.AuthenticationException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService customUserDetailsService;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    // List of paths that don't require authentication
    private final List<String> publicPaths = Arrays.asList(
            "/api/auth/**",
            "/api/test/public"
    );

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) {
        String path = request.getServletPath();
        return publicPaths.stream()
                .anyMatch(pattern -> pathMatcher.match(pattern, path));
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt)) {
                if (!tokenProvider.validateToken(jwt)) {
                    throw new AuthenticationException("Invalid or expired JWT token");
                }

                String username = tokenProvider.getUsernameFromToken(jwt);
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                UsernamePasswordAuthenticationToken authentication =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
            SecurityContextHolder.clearContext();

            if (ex instanceof AuthenticationException) {
                throw ex;
            }
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    /**
     * Helper method to check if token is about to expire
     * Could be used to implement token refresh logic
     */
    private boolean shouldRefreshToken(String token) {
        return tokenProvider.isTokenExpired(token, false);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/JwtTokenProvider.java">
package com.bht.ludonova.security;


import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey accessTokenKey;
    private final SecretKey refreshTokenKey;
    private final long accessTokenExpirationMs; // Changed to long
    private final long refreshTokenExpirationMs; // Changed to long

    public JwtTokenProvider(
            @Value("${jwt.secret}") String jwtSecret,
            @Value("${jwt.refresh-secret:${jwt.secret}}") String refreshSecret,
            @Value("${jwt.expiration}") long accessTokenExpirationMs, // Changed to long
            @Value("${jwt.refresh-expiration:2592000000}") long refreshTokenExpirationMs) { // Changed to long
        this.accessTokenKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        this.refreshTokenKey = Keys.hmacShaKeyFor(refreshSecret.getBytes(StandardCharsets.UTF_8));
        this.accessTokenExpirationMs = accessTokenExpirationMs;
        this.refreshTokenExpirationMs = refreshTokenExpirationMs;
    }

    public String generateAccessToken(Authentication authentication) {
        return generateAccessToken(authentication.getName(), createClaims(authentication));
    }

    public String generateAccessToken(String username) {
        return generateAccessToken(username, new HashMap<>());
    }

    public String generateAccessToken(String username, Map<String, Object> claims) {
        return generateToken(username, claims, accessTokenKey, accessTokenExpirationMs);
    }

    public String generateRefreshToken(String username) {
        return generateToken(username, new HashMap<>(), refreshTokenKey, refreshTokenExpirationMs);
    }

    private String generateToken(String username, Map<String, Object> claims, SecretKey key, long expirationMs) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMs);

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    private Map<String, Object> createClaims(Authentication authentication) {
        Map<String, Object> claims = new HashMap<>();

        // Add user authorities/roles
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        claims.put("authorities", authorities);

        // Add token type
        claims.put("type", "Bearer");

        return claims;
    }

    public String getUsernameFromToken(String token, boolean isRefreshToken) {
        return getClaimsFromToken(token, isRefreshToken).getSubject();
    }

    public String getUsernameFromToken(String token) {
        return getUsernameFromToken(token, false);
    }

    public boolean validateToken(String token) {
        return validateToken(token, false);
    }

    public boolean validateToken(String token, boolean isRefreshToken) {
        try {
            SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
            Jwts.parserBuilder()
                    .setSigningKey(key)
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            log.error("Invalid JWT signature: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    public Claims getClaimsFromToken(String token, boolean isRefreshToken) {
        SecretKey key = isRefreshToken ? refreshTokenKey : accessTokenKey;
        return Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    public boolean isTokenExpired(String token, boolean isRefreshToken) {
        try {
            Claims claims = getClaimsFromToken(token, isRefreshToken);
            return claims.getExpiration().before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    public long getAccessTokenExpirationMs() {
        return accessTokenExpirationMs;
    }

    public long getRefreshTokenExpirationMs() {
        return refreshTokenExpirationMs;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/security/SecurityConfig.java">
package com.bht.ludonova.security;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthFilter;
    private final CorsConfigurationSource corsConfigurationSource;
    private final AuthenticationExceptionHandler authenticationExceptionHandler;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        return http
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(auth -> auth
                        // Public endpoints
                        .requestMatchers(
                                "/api/auth/login",
                                "/api/auth/refresh",
                                "/api/auth/steam/login",
                                "/api/auth/steam/return"
                        ).permitAll()
                        .requestMatchers("/api/test/public").permitAll()
                        // Protected endpoints
                        .requestMatchers("/api/games/**").authenticated()
                        .requestMatchers("/api/user/**").authenticated()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .exceptionHandling(exc -> exc
                        .authenticationEntryPoint(authenticationExceptionHandler)
                        .accessDeniedHandler(authenticationExceptionHandler)
                )
                .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/AuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;

import java.util.Map;

public interface AuthenticationStrategy {
    AuthenticationResponse authenticate(Map<String, String> credentials);
    AuthenticationResponse refresh(String refreshToken);
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/BasicAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class BasicAuthenticationStrategy implements AuthenticationStrategy {
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    public BasicAuthenticationStrategy(
            AuthenticationManager authenticationManager,
            JwtTokenProvider tokenProvider,
            UserService userService) {
        this.authenticationManager = authenticationManager;
        this.tokenProvider = tokenProvider;
        this.userService = userService;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> credentials) {
        try {
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            credentials.get("username"),
                            credentials.get("password")
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authentication);

            String accessToken = tokenProvider.generateAccessToken(authentication);
            String refreshToken = tokenProvider.generateRefreshToken(authentication.getName());
            UserDTO user = userService.getCurrentUserDTO();

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (org.springframework.security.core.AuthenticationException e) {
            log.error("Authentication failed", e);
            throw new AuthenticationException("Invalid username or password");
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        try {
            if (!tokenProvider.validateToken(refreshToken, true)) {
                throw new AuthenticationException("Invalid refresh token");
            }

            String username = tokenProvider.getUsernameFromToken(refreshToken, true);
            UserDTO user = userService.getUserDTOByUsername(username);

            String newAccessToken = tokenProvider.generateAccessToken(username);
            String newRefreshToken = tokenProvider.generateRefreshToken(username);

            TokenResponse tokens = TokenResponse.of(
                    newAccessToken,
                    newRefreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, user);
        } catch (Exception e) {
            log.error("Token refresh failed", e);
            throw new AuthenticationException("Failed to refresh token");
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/auth/SteamAuthenticationStrategy.java">
package com.bht.ludonova.service.auth;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.dto.auth.TokenResponse;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.SteamAuthenticationException;
import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.security.JwtTokenProvider;
import com.bht.ludonova.service.SteamService;
import com.bht.ludonova.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class SteamAuthenticationStrategy implements AuthenticationStrategy {
    private final SteamService steamService;
    private final UserService userService;
    private final JwtTokenProvider tokenProvider;

    public SteamAuthenticationStrategy(
            SteamService steamService,
            UserService userService,
            JwtTokenProvider tokenProvider) {
        this.steamService = steamService;
        this.userService = userService;
        this.tokenProvider = tokenProvider;
    }

    @Override
    public AuthenticationResponse authenticate(Map<String, String> openIdParams) {
        try {
            if (!steamService.validateSteamResponse(openIdParams)) {
                throw new SteamAuthenticationException("Invalid Steam response");
            }

            String steamId = extractSteamId(openIdParams);
            if (steamId == null) {
                throw new SteamAuthenticationException("Could not extract Steam ID");
            }

            SteamUser steamUser = steamService.fetchUserDetails(steamId);
            User user = userService.getOrCreateSteamUser(steamUser);

            String accessToken = tokenProvider.generateAccessToken(user.getUsername());
            String refreshToken = tokenProvider.generateRefreshToken(user.getUsername());
            UserDTO userDTO = userService.convertToDTO(user);

            TokenResponse tokens = TokenResponse.of(
                    accessToken,
                    refreshToken,
                    tokenProvider.getAccessTokenExpirationMs()
            );

            return new AuthenticationResponse(tokens, userDTO);
        } catch (Exception e) {
            log.error("Steam authentication failed", e);
            throw new SteamAuthenticationException(e.getMessage());
        }
    }

    @Override
    public AuthenticationResponse refresh(String refreshToken) {
        return null; // Steam users use the same refresh mechanism as basic auth
    }

    private String extractSteamId(Map<String, String> params) {
        String identity = params.get("openid.claimed_id");
        if (identity != null && identity.matches("https://steamcommunity.com/openid/id/\\d+")) {
            return identity.substring(identity.lastIndexOf("/") + 1);
        }
        return null;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/AuthenticationService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.auth.AuthenticationResponse;
import com.bht.ludonova.exception.AuthenticationException;
import com.bht.ludonova.service.auth.AuthenticationStrategy;
import com.bht.ludonova.service.auth.BasicAuthenticationStrategy;
import com.bht.ludonova.service.auth.SteamAuthenticationStrategy;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@Slf4j
public class AuthenticationService {
    private final Map<String, AuthenticationStrategy> authenticationStrategies;

    public AuthenticationService(
            BasicAuthenticationStrategy basicAuthStrategy,
            SteamAuthenticationStrategy steamAuthStrategy) {
        this.authenticationStrategies = Map.of(
                "basic", basicAuthStrategy,
                "steam", steamAuthStrategy
        );
    }

    public AuthenticationResponse authenticate(String strategy, Map<String, String> credentials) {
        AuthenticationStrategy authStrategy = authenticationStrategies.get(strategy);
        if (authStrategy == null) {
            throw new AuthenticationException("Unsupported authentication strategy: " + strategy);
        }

        return authStrategy.authenticate(credentials);
    }

    public AuthenticationResponse refresh(String refreshToken) {
        // We use the basic strategy for refresh tokens as the mechanism is the same
        return authenticationStrategies.get("basic").refresh(refreshToken);
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/SteamService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamApiResponseDTO;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import com.bht.ludonova.model.SteamUser;

import lombok.extern.slf4j.Slf4j;

import java.util.Map;

@Slf4j
@Service
public class SteamService {
    @Value("${steam.api.key}")
    private String steamApiKey;

    private final WebClient webClient;

    public SteamService() {
        this.webClient = WebClient.builder()
                .baseUrl("https://api.steampowered.com")
                .build();
    }

    public SteamUser fetchUserDetails(String steamId) {
        String url = "/ISteamUser/GetPlayerSummaries/v2/";

        try {
            SteamApiResponseDTO dto = webClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path(url)
                            .queryParam("key", steamApiKey)
                            .queryParam("steamids", steamId)
                            .build())
                    .retrieve()
                    .bodyToMono(SteamApiResponseDTO.class)
                    .block();

            if (dto != null && dto.getResponse() != null && !dto.getResponse().getPlayers().isEmpty()) {
                SteamApiResponseDTO.Player player = dto.getResponse().getPlayers().get(0);
                return mapToSteamUser(player);
            }

            throw new SteamApiException("Failed to fetch Steam user details");

        } catch (Exception e) {
            log.error("Error fetching Steam user details", e);
            throw new SteamApiException("Failed to fetch Steam user details", e);
        }
    }

    private SteamUser mapToSteamUser(SteamApiResponseDTO.Player player) {
        SteamUser steamUser = new SteamUser();
        steamUser.setSteamId(player.getSteamId());
        steamUser.setPersonaName(player.getPersonaName());
        steamUser.setProfileUrl(player.getProfileUrl());
        steamUser.setAvatarUrl(player.getAvatarUrl());
        return steamUser;
    }

    public boolean validateSteamResponse(Map<String, String> params) {
        try {
            log.info("Validating Steam response with params: {}", params);
            String url = "https://steamcommunity.com/openid/login";
            params.put("openid.mode", "check_authentication");

            WebClient.ResponseSpec response = webClient.post()
                .uri(url)
                .bodyValue(params)
                .retrieve();

            String responseBody = response.bodyToMono(String.class).block();
            log.info("Steam validation response: {}", responseBody);
            return responseBody != null && responseBody.contains("is_valid:true");
        } catch (Exception e) {
            log.error("Error validating Steam response", e);
            return false;
        }
    }

    public static class SteamApiException extends RuntimeException {
        public SteamApiException(String message) {
            super(message);
        }
        
        public SteamApiException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/service/UserService.java">
package com.bht.ludonova.service;

import com.bht.ludonova.dto.steam.SteamUserDTO;
import com.bht.ludonova.dto.user.UserDTO;
import com.bht.ludonova.exception.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.bht.ludonova.model.SteamUser;
import com.bht.ludonova.model.User;
import com.bht.ludonova.repository.UserRepository;

import java.util.UUID;

@Service
@Transactional
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    public User getOrCreateSteamUser(SteamUser steamUser) {
        return userRepository.findBySteamUser_SteamId(steamUser.getSteamId())
                .orElseGet(() -> createSteamUser(steamUser));
    }

    private User createSteamUser(SteamUser steamUser) {
        User user = new User();
        user.setUsername("steam_" + steamUser.getSteamId());
        user.setPassword(passwordEncoder.encode(UUID.randomUUID().toString()));
        user.setSteamUser(steamUser);
        return userRepository.save(user);
    }

    public UserDTO getCurrentUserDTO() {
        String username = SecurityContextHolder.getContext().getAuthentication().getName();
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found"));
    }

    public UserDTO getUserDTOByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(this::convertToDTO)
                .orElseThrow(() -> new AuthenticationException("User not found: " + username));
    }

    public UserDTO convertToDTO(User user) {
        UserDTO dto = new UserDTO();
        dto.setId(user.getId());
        dto.setUsername(user.getUsername());
        dto.setEmail(user.getEmail());

        if (user.getSteamUser() != null) {
            SteamUserDTO steamUserDTO = new SteamUserDTO();
            steamUserDTO.setSteamId(user.getSteamUser().getSteamId());
            steamUserDTO.setPersonaName(user.getSteamUser().getPersonaName());
            steamUserDTO.setProfileUrl(user.getSteamUser().getProfileUrl());
            steamUserDTO.setAvatarUrl(user.getSteamUser().getAvatarUrl());
            dto.setSteamUser(steamUserDTO);
        }

        return dto;
    }
}
</file>

<file path="src/main/java/com/bht/ludonova/LudoNovaApplication.java">
package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@SpringBootApplication
@EntityScan("com.bht.ludonova.model")
@EnableJpaRepositories("com.bht.ludonova.repository")
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}
</file>

<file path="src/main/resources/application.properties">
# Server Configuration
server.port=8080

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres

# JPA/Hibernate Configuration
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Enable SQL initialization
spring.sql.init.mode=always

# JWT Configuration
jwt.secret=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
jwt.refresh-secret=7338782F413F4428472B4B6250645367566B5970404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970404E635266556A586E

# Token expiration times (in milliseconds)
# Access token: 1 hour = 3600000 ms
jwt.expiration=3600000
# Refresh token: 30 days = 2592000000 ms
jwt.refresh-expiration=2592000000

# CORS Configuration
#spring.web.cors.allowed-origins=http://localhost:3000
#spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
#spring.web.cors.allowed-headers=*
#spring.web.cors.allow-credentials=true

# CORS Configuration
cors.allowed-origins=http://localhost:3000

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# Steam Configuration
steam.api.key=${STEAM_API_KEY}
steam.return.url=${STEAM_RETURN_URL:http://localhost:3000/auth/steam/callback}
steam.realm.url=${STEAM_REALM_URL:http://localhost:3000}
</file>

<file path=".env.example">
# Steam Configuration
STEAM_API_KEY=your_steam_api_key_here
STEAM_RETURN_URL=http://localhost:3000/auth/steam/callback
</file>

<file path=".gitignore">
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

### Environment Files ###
.env
application-local.properties
application-dev.properties
application-prod.properties

### Logs ###
*.log
logs/
log/

### Docker ###
docker-compose.override.yml

### OS generated files ###
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

### Java ###
# Compiled class file
*.class

# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar

# virtual machine crash logs
hs_err_pid*
replay_pid*
</file>

<file path="backend-overview.md">
# LudoNova Backend Overview

The LudoNova backend is a robust and scalable **Spring Boot** application that powers the game backlog management system. It is designed with a focus on security, maintainability, and performance, ensuring a seamless experience for both developers and users.

## Understanding Spring and Spring Boot

Before diving into the architecture and components of the LudoNova backend, it's essential to understand the foundational frameworks it leverages: **Spring** and **Spring Boot**.

### What is Spring?

**Spring** is a comprehensive framework for building Java applications. It provides a wide range of features, including:

- **Dependency Injection (DI):** Allows for loose coupling of components by managing their dependencies.
- **Aspect-Oriented Programming (AOP):** Enables separation of cross-cutting concerns like logging and security.
- **Data Access:** Simplifies interactions with databases through modules like Spring JDBC and Spring Data.
- **Transaction Management:** Provides declarative transaction management for consistent data operations.
- **Model-View-Controller (MVC) Framework:** Facilitates the creation of web applications with clear separation between the model, view, and controller layers.

However, setting up a Spring application often involves extensive configuration, which can be time-consuming and error-prone.

### What is Spring Boot?

**Spring Boot** builds upon the Spring framework to simplify the development process. It offers:

- **Auto-Configuration:** Automatically configures Spring components based on the dependencies present in the project.
- **Starter POMs:** Pre-configured Maven or Gradle dependencies that simplify dependency management.
- **Embedded Servers:** Allows running applications with embedded servers like Tomcat or Jetty without the need for external deployment.
- **Production-Ready Features:** Includes metrics, health checks, and externalized configuration to prepare applications for production environments.

In essence, Spring Boot reduces the boilerplate configuration, enabling developers to focus more on business logic rather than setup.

## Architecture

The backend follows a **layered architecture**, a common design pattern in Spring Boot applications that separates concerns to enhance modularity and ease of maintenance. This structure aligns with Spring's philosophy of separation of concerns and facilitates scalability and testability. The primary layers include:

- **Controller Layer:** Handles incoming HTTP requests and maps them to appropriate services.
  
  - **Why It's Separate:** Isolating controllers ensures that request handling logic is decoupled from business logic, making the system more modular and easier to manage.

- **Service Layer:** Contains the business logic and processes data between the controller and repository layers.
  
  - **Role in Spring Boot:** Services are annotated with `@Service`, a specialization of `@Component`, which allows Spring to detect and manage them as beans. This layer orchestrates operations, enforces business rules, and acts as an intermediary between controllers and repositories.

- **Repository Layer:** Manages data persistence and interacts with the PostgreSQL database using JPA/Hibernate.
  
  - **Integration with Spring Data:** Repositories are typically interfaces annotated with `@Repository`. Spring Data JPA provides implementations at runtime, abstracting the data access layer and enabling CRUD operations without boilerplate code.

### How These Layers Work Together

1. **Request Flow:**
   - A client sends an HTTP request to the application.
   - The **Controller** receives the request and delegates processing to the **Service** layer.
   - The **Service** contains the business logic and interacts with the **Repository** to perform CRUD operations.
   - The **Repository** communicates with the PostgreSQL database to fetch or persist data.
   - The **Service** processes the data and returns the result to the **Controller**.
   - The **Controller** sends the appropriate HTTP response back to the client.

2. **Benefits of Layered Architecture:**
   - **Modularity:** Each layer has a distinct responsibility, making the codebase easier to navigate and maintain.
   - **Testability:** Layers can be tested independently, facilitating unit and integration testing.
   - **Scalability:** Allows for individual layers to be scaled or modified without affecting others.
   - **Maintainability:** Enhances code readability and simplifies the addition of new features.

## Authentication and Security

Security is a paramount concern in the LudoNova backend. Leveraging Spring Boot's robust security features, the application employs a JWT (JSON Web Token) based authentication system to ensure secure and stateless user sessions.

### Understanding Spring Security

**Spring Security** is a powerful and highly customizable authentication and access-control framework. It integrates seamlessly with Spring Boot applications, providing:

- **Authentication:** Verifies the identity of users.
- **Authorization:** Controls access to resources based on user roles and permissions.
- **Protection Against Common Vulnerabilities:** Guards against threats like CSRF, XSS, and session fixation.

### Key Components:

- **JwtTokenProvider:** Generates, validates, and parses JWT tokens. It uses HMAC-SHA for token signing with a configurable secret key and expiration time.
  
  ```java
  public String generateToken(String username) { /* ... */ }
  public String getUsernameFromJWT(String token) { /* ... */ }
  public boolean validateToken(String authToken) { /* ... */ }
  ```
  
  - **Role in Spring Security:** Acts as a utility for managing JWT operations, ensuring tokens are securely created and validated.

- **JwtAuthenticationFilter:** Intercepts incoming requests to extract and validate JWT tokens. If valid, it sets the authentication in the Spring Security context.
  
  - **Integration with Spring Boot:** Extends `OncePerRequestFilter` to ensure that each request is processed once. It leverages the `JwtTokenProvider` to manage token validation and sets the security context accordingly.

- **SecurityConfig:** Configures Spring Security, defining public and protected endpoints, setting up the authentication provider, and applying security filters.
  
  - **Configuration Highlights:**
    - **CORS:** Configures Cross-Origin Resource Sharing to allow or restrict requests from specific origins.
    - **CSRF:** Disables Cross-Site Request Forgery protection for stateless APIs.
    - **Session Management:** Configures the application to be stateless, relying solely on JWT tokens without maintaining server-side sessions.
    - **Authentication Provider:** Sets up how authentication is handled, typically using a `DaoAuthenticationProvider` that retrieves user details from a data source.

### Security Features:

- **Stateless Authentication:** No server-side sessions are maintained. All authentication is handled via JWT tokens sent with each request.
  
  - **Advantages:** Enhances scalability as the server doesn't need to store session information. It also simplifies horizontal scaling and load balancing.

- **Password Encryption:** User passwords are hashed using BCrypt to ensure they are not stored in plain text.
  
  - **Security Best Practice:** Hashing passwords protects user credentials even if the database is compromised.

- **CORS Configuration:** Restricts backend access to authorized frontend origins and specific HTTP methods.
  
  - **Purpose:** Prevents unauthorized domains from making requests to the backend, mitigating potential cross-origin attacks.

## API Endpoints

The backend exposes a set of RESTful API endpoints to manage user authentication, games, and user profiles. Leveraging Spring Boot's **Spring MVC** framework, these endpoints are defined using annotations that map HTTP requests to handler methods.

### Examples:

- **Authentication:**
  - `POST /api/auth/login`: Authenticates a user and returns a JWT token.
  - `POST /api/auth/register`: Registers a new user.

- **Games Management:**
  - `GET /api/games`: Retrieves a list of games.
  - `POST /api/games`: Adds a new game to the backlog.
  - `PUT /api/games/{id}`: Updates game details.
  - `DELETE /api/games/{id}`: Removes a game from the backlog.

- **User Profiles:**
  - `GET /api/user`: Retrieves the authenticated user's profile information.

### Leveraging Spring MVC:

- **Controllers:** Annotated with `@RestController`, these classes handle HTTP requests and return responses.
- **Request Mappings:** Methods within controllers use annotations like `@GetMapping`, `@PostMapping`, etc., to map specific HTTP methods and URLs to handler functions.
- **Response Entities:** Facilitates building HTTP responses with appropriate status codes and headers.

## Database Management

The application uses **PostgreSQL** as its primary database, with the schema managed by **JPA/Hibernate**. Spring Boot's integration with Spring Data JPA simplifies database interactions, allowing developers to work with databases using Java objects rather than writing SQL queries.

### Benefits of Using JPA/Hibernate:

- **Object-Relational Mapping (ORM):** Translates Java objects to database tables, enabling developers to interact with the database using familiar Java constructs.
- **Schema Generation:** Automatically creates and updates the database schema based on entity classes, reducing manual configuration.
- **Query Abstraction:** Provides a high-level API for querying the database, such as JPQL or the Criteria API, abstracting the underlying SQL.

### Configuration:

```properties
# application.properties
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=yourusername
spring.datasource.password=yourpassword
spring.jpa.hibernate.ddl-auto=update
```

- **spring.datasource.url:** Specifies the JDBC URL for the PostgreSQL database.
- **spring.jpa.hibernate.ddl-auto:** Determines how Hibernate handles schema generation. The `update` value ensures that the schema is automatically updated based on entity changes.

## Testing and Deployment

### Testing:

Comprehensive tests are implemented to ensure the reliability and correctness of the backend functionalities. Leveraging **Spring Boot's testing framework**, developers can write unit and integration tests with ease.

- **Running Tests:**
  
  ```bash
  ./mvnw test
  ```
  
  - **Spring Boot Test Annotations:** Annotations like `@SpringBootTest` facilitate loading the application context and testing components in an integrated environment.
  
- **Benefits:**
  - **Continuous Integration:** Ensures that new changes do not break existing functionalities.
  - **Quality Assurance:** Maintains high code quality and reliability.

### Deployment:

The backend can be containerized using **Docker** and managed with **Docker Compose**. This facilitates consistent environments across development, testing, and production.

- **Containerization with Docker:**
  
  ```bash
  docker-compose up -d
  ```
  
  - **Advantages:**
    - **Isolation:** Ensures that the application runs in a consistent environment, eliminating "it works on my machine" issues.
    - **Scalability:** Simplifies scaling services horizontally.
    - **Portability:** Enables easy deployment across different environments and cloud platforms.

### Prerequisites:

- **Java 17+:** Required to run the Spring Boot application.
- **Maven:** For building and managing dependencies.
- **Docker and Docker Compose:** For containerization and deployment.

## Integration with Frontend

The backend seamlessly integrates with the **React/Next.js** frontend of the LudoNova application. Authentication tokens are managed on the frontend and included in API requests to secure endpoints.

### API Client:

A configured Axios instance is used on the frontend to handle API requests, automatically attaching JWT tokens and handling authentication errors.

```javascript
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});
```

- **Interceptors:** Axios interceptors can be set up to inject JWT tokens into request headers and handle responses globally, such as redirecting to the login page on a `401 Unauthorized` response.

## Conclusion

The LudoNova backend is meticulously crafted using **Spring Boot** to provide a secure, efficient, and scalable foundation for the game backlog management system. Its thoughtful layered architecture and robust security measures ensure a reliable service for users, while Spring Boot's auto-configuration and integration capabilities facilitate ease of development and maintenance. Understanding how Spring Boot orchestrates its components and leverages frameworks like Spring MVC and Spring Data JPA empowers developers to effectively manage and extend the backend functionalities.

```
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: ludonova_db
    environment:
      POSTGRES_DB: ludonova
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.bht</groupId>
    <artifactId>ludonova</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ludonova</name>
    <description>Backend for LudoNova game backlog manager</description>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Environment Variables -->
        <dependency>
            <groupId>me.paulschwarz</groupId>
            <artifactId>spring-dotenv</artifactId>
            <version>4.0.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="README.md">
# LudoNova Backend

Spring Boot backend for the LudoNova game backlog manager.

## Prerequisites

- Java 17+
- Maven
- Docker and Docker Compose

## Getting Started

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/ludonova-backend.git
   ```

2. Start the PostgreSQL database:
   ```bash
   docker-compose up -d
   ```

3. To stop and remove the container (but keep the data volume):
   ```bash
   docker-compose down
   ```

4. To remove everything including the volume:
   ```bash
   docker-compose down -v
   ```
   Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.

4. Alternatively, if you just want to restart the container without stopping and recreating it:
   ```bash
   docker restart ludonova_db
   ```

5. Run the application:
   ```bash
   ./mvnw spring-boot:run
   ```

## API Documentation

The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.

## Database

The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.

## Testing

Run tests with:
```bash
./mvnw test
```
```
</file>

<file path="setup.sh">
#!/bin/bash

# Navigate to the backend directory
cd ludonova-backend

# Create main directory structure
mkdir -p src/main/java/com/bht/ludonova
mkdir -p src/main/resources
mkdir -p src/test/java/com/bht/ludonova
mkdir -p src/test/resources

# Create package directories
cd src/main/java/com/bht/ludonova
mkdir config
mkdir controller
mkdir model
mkdir repository
mkdir service
mkdir security
mkdir dto
mkdir exception

# Create application.properties
cd ../../resources
echo "# Server Configuration
server.port=8080

# Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# JWT Configuration
jwt.secret=your-secret-key-here
jwt.expiration=86400000

# CORS Configuration
spring.web.cors.allowed-origins=http://localhost:3000
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG" > application.properties

# Create main application class
cd ../java/com/bht/ludonova
echo "package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}" > LudoNovaApplication.java
</file>

</repository_files>
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
        <relativePath/>
    </parent>

    <groupId>com.bht</groupId>
    <artifactId>ludonova</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ludonova</name>
    <description>Backend for LudoNova game backlog manager</description>

    <properties>
        <java.version>17</java.version>
        <jjwt.version>0.11.5</jjwt.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Environment Variables -->
        <dependency>
            <groupId>me.paulschwarz</groupId>
            <artifactId>spring-dotenv</artifactId>
            <version>4.0.0</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path="README.md">
# LudoNova Backend

Spring Boot backend for the LudoNova game backlog manager.

## Prerequisites

- Java 17+
- Maven
- Docker and Docker Compose

## Getting Started

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/ludonova-backend.git
   ```

2. Start the PostgreSQL database:
   ```bash
   docker-compose up -d
   ```

3. To stop and remove the container (but keep the data volume):
   ```bash
   docker-compose down
   ```

4. To remove everything including the volume:
   ```bash
   docker-compose down -v
   ```
   Remember that after a full reset, your database will be empty and you'll need to run your application to reinitialize it with any seed data (like the test user) defined in DataInitializer.java.

4. Alternatively, if you just want to restart the container without stopping and recreating it:
   ```bash
   docker restart ludonova_db
   ```

5. Run the application:
   ```bash
   ./mvnw spring-boot:run
   ```

## API Documentation

The API documentation is available at http://localhost:8080/swagger-ui.html when running in development mode.

## Database

The application uses PostgreSQL. The database schema is managed by JPA/Hibernate and will be created automatically on startup.

## Testing

Run tests with:
```bash
./mvnw test
```
```
</file>

<file path="setup.sh">
#!/bin/bash

# Navigate to the backend directory
cd ludonova-backend

# Create main directory structure
mkdir -p src/main/java/com/bht/ludonova
mkdir -p src/main/resources
mkdir -p src/test/java/com/bht/ludonova
mkdir -p src/test/resources

# Create package directories
cd src/main/java/com/bht/ludonova
mkdir config
mkdir controller
mkdir model
mkdir repository
mkdir service
mkdir security
mkdir dto
mkdir exception

# Create application.properties
cd ../../resources
echo "# Server Configuration
server.port=8080

# Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/ludonova
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# JWT Configuration
jwt.secret=your-secret-key-here
jwt.expiration=86400000

# CORS Configuration
spring.web.cors.allowed-origins=http://localhost:3000
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*

# Logging Configuration
logging.level.com.bht.ludonova=DEBUG" > application.properties

# Create main application class
cd ../java/com/bht/ludonova
echo "package com.bht.ludonova;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LudoNovaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LudoNovaApplication.class, args);
    }
}" > LudoNovaApplication.java
</file>

</repository_files>
